-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bioinformatics pipelines with shake
--   
--   Bioinformatics pipelines with shake
@package bioshake
@version 0.1.0.0


-- | This modules provides implicit parameters, intended for passing
--   default and overrideable configuration options. It is based on
--   implicit-params in hackage.
module Bioshake.Implicit
class Default a
def :: Default a => a
class Implicit a
param :: Implicit a => a
newtype Param a b
Param :: (Implicit a => b) -> Param a b
setParam :: forall a b. a -> (Implicit a => b) -> b
($~) :: forall a b. (Implicit a => b) -> a -> b
infixl 1 $~
instance Bioshake.Implicit.Default a => Bioshake.Implicit.Implicit a


-- | Core data types the pipeline abstraction.
module Bioshake.Types

-- | Pipes output of phase a into phase b, i.e., forms a pipeline.
data (:->) a b
[:->] :: a -> b -> a :-> b

-- | Buildable abstracts things that can be turned into shake
--   <a>Action</a>s.
class Buildable a
build :: (Buildable a, Implicit Resource) => a -> Action ()

-- | The compiler tracks the set of output files to ensure duplicate
--   <a>Rules</a> are not generated. This allows multiple potentially
--   overlapping pipelines to be compiled down to a set of unique
--   <a>Rules</a>.
type Compiler = StateT (Set [FilePath]) Rules

-- | Compile pipelines to <a>Rules</a>.
compileRules :: Compiler () -> Rules ()

-- | Pipelines are <a>Compilable</a> when they can be compiled down to a
--   set of <a>Rules</a> that build a list of output paths.
class Compilable a where compile = return $ return mempty
compile :: (Compilable a, Implicit Resource) => a -> Compiler ()

-- | A pipeline <tt>a :-&gt; b</tt> is <a>Compilable</a> to <a>Rules</a> if
--   <tt>a</tt> is <a>Compilable</a> and we can generate an <a>Action</a>
--   to build <tt>a:-&gt;b</tt> (i.e., <tt>a:-&gt;b</tt> is
--   <a>Buildable</a>). This generates a <a>Rules</a> which builds the
--   <a>paths</a> of <tt>a:-&gt;b</tt> and <a>need</a>s the <a>paths</a> of
--   <tt>a</tt>.

-- | Things are pathable if they can be mapped to a list of file paths.
--   This is used to make the files for a phase concrete in the build
--   system.
class Pathable a
paths :: Pathable a => a -> [FilePath]
data Nuc
A :: Nuc
C :: Nuc
G :: Nuc
T :: Nuc
newtype Seq
Seq :: [Nuc] -> Seq
data Threads
Threads :: Int -> Threads
instance GHC.Show.Show Bioshake.Types.Threads
instance GHC.Classes.Eq Bioshake.Types.Seq
instance GHC.Show.Show Bioshake.Types.Nuc
instance GHC.Classes.Eq Bioshake.Types.Nuc
instance (Bioshake.Types.Pathable a, Bioshake.Types.Pathable (a Bioshake.Types.:-> b), Bioshake.Types.Compilable a, Bioshake.Types.Buildable (a Bioshake.Types.:-> b)) => Bioshake.Types.Compilable (a Bioshake.Types.:-> b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a Bioshake.Types.:-> b)
instance GHC.Show.Show Bioshake.Types.Seq
instance Data.String.IsString Bioshake.Types.Seq


-- | This module introduces a set of common tags that are frequently used
--   when defining phases.
module Bioshake.Tags

-- | Duplicated reads have been removed
class DeDuped a

-- | Contains an RG line
class HasRG a

-- | Results from a paired end sequencing processed
class PairedEnd a

-- | Sorted (e.g., sorted sam/bam, or bed)
class Sorted a
class IsBam a
class IsBcf a
class IsBed a
class IsCSV a
class IsFastQ a
class IsGff a
class IsMPileup a
class IsSam a
class IsSeqzGZ a
class IsTSV a
class IsVCF a
class IsTGZ a
class IsCov a
allTags :: [Name]

-- | Template haskell to declare transitivity for all tags through a pipe
--   ending in a type. Examples include <a>Out</a>.
allTransTagsPipe :: Name -> Q [Dec]

-- | Same as <a>allTransTagsPipe</a> but for transitivity through a
--   constructor. Examples include <a>All</a>.
allTransTags :: Name -> Q [Dec]
instance Bioshake.Tags.DeDuped a => Bioshake.Tags.DeDuped (a Bioshake.Types.:-> b)
instance (Bioshake.Tags.HasRG a, Bioshake.Tags.IsBam (a Bioshake.Types.:-> b)) => Bioshake.Tags.HasRG (a Bioshake.Types.:-> b)
instance Bioshake.Tags.PairedEnd a => Bioshake.Tags.PairedEnd (a Bioshake.Types.:-> b)

module Bioshake.Cluster.Torque
type ModuleName = String
type Queue = String
data TOption
Mem :: Int -> TOption
CPUs :: Int -> TOption
Walltime :: Int -> TOption
Queue :: String -> TOption
Module :: ModuleName -> TOption
TStdout :: FilePath -> TOption
newtype Config
Config :: [TOption] -> Config
getCPUs :: Config -> Int
class TArgs a
cmdArgs :: TArgs a => [Either TOption String] -> a
class Args a
args :: Args a => a -> [Either TOption String]
type (|->) a b = a
submit :: TArgs a => a |-> Action ()
gb :: Num a => a -> a
instance GHC.Show.Show Bioshake.Cluster.Torque.TOption
instance GHC.Classes.Eq Bioshake.Cluster.Torque.TOption
instance (Bioshake.Cluster.Torque.Args a, Bioshake.Cluster.Torque.TArgs r) => Bioshake.Cluster.Torque.TArgs (a -> r)
instance Bioshake.Cluster.Torque.TArgs (Development.Shake.Core.Action ())
instance Bioshake.Cluster.Torque.TArgs (GHC.Types.IO ())
instance Bioshake.Cluster.Torque.Args GHC.Base.String
instance Bioshake.Cluster.Torque.Args [GHC.Base.String]
instance Bioshake.Cluster.Torque.Args Bioshake.Cluster.Torque.TOption
instance Bioshake.Cluster.Torque.Args Bioshake.Cluster.Torque.Config
instance (Bioshake.Cluster.Torque.Args a, Bioshake.Cluster.Torque.Args b) => Bioshake.Cluster.Torque.Args (Data.Either.Either a b)
instance (Bioshake.Cluster.Torque.Args a, Bioshake.Cluster.Torque.Args b) => Bioshake.Cluster.Torque.Args [Data.Either.Either a b]


-- | Bioshake is a small framework for specifying bioinformatics pipelines.
--   The goal is to specify phases in a forward chaining manner (as is
--   natural for the domain) while guaranteeing as much robustness as
--   possible to errors such as mismatched file types or other attributes.
--   Almost everything is handled in the type system, and pipelines are
--   compiled down to <a>Development.Shake</a> <a>Rules</a> for actual
--   execution.
module Bioshake

-- | Datatype to represent fan-in combinations.
data All a
[All] :: (Functor f, Foldable f) => f a -> All a

-- | Attaches a reference genome.
class Referenced a where dbnsfp _ = error "dbNSFP not available"

-- | The path to the reference fasta file.
getRef :: Referenced a => a -> FilePath

-- | The short name, e.g., hg19.
name :: Referenced a => a -> String

-- | Path to dbNSFP for the genome
dbnsfp :: Referenced a => a -> FilePath

-- | Asserts a capture region.
class Capture a
getBED :: Capture a => a -> FilePath
ignoringIOErrors :: IO () -> IO ()

-- | Creates a temporary directory under a target directory according to a
--   naming template. The directory is cleaned up after executing the
--   action. This differs from <a>Development.Shake</a>'s
--   <a>withTempDir</a> in that it takes a target directory and template
--   whereas <a>Development.Shake</a> uses /tmp. This is generally more
--   useful, as ./tmp is used as the target directory by convention in
--   BioShake.
withTempDirectory :: FilePath -> String -> (FilePath -> Action b) -> Action b

-- | Entry point to bioshake. Like <a>shakeArgs</a> but also takes a number
--   of threads to use.
bioshake :: Int -> ShakeOptions -> (Implicit Resource => Rules ()) -> IO ()

-- | Explicitly names an output product. Outputs are automatically named in
--   the temporary directory except for this special case: this is how you
--   obtain the artifacts you are specifically interested in.
out :: [FilePath] -> Out

-- | Fan-in style combinator. Takes a collection of combines their output
--   paths as input paths for the subsequent phase.
withAll :: (Functor f, Foldable f) => f a -> All a

-- | Explicitly construct a fan-in of exactly two items
withPair :: a -> a -> All a
instance Bioshake.Tags.IsFastQ a0 => Bioshake.Tags.IsFastQ (Bioshake.All a0)
instance Bioshake.Tags.DeDuped a0 => Bioshake.Tags.DeDuped (Bioshake.All a0)
instance Bioshake.Tags.HasRG a0 => Bioshake.Tags.HasRG (Bioshake.All a0)
instance Bioshake.Tags.IsBam a0 => Bioshake.Tags.IsBam (Bioshake.All a0)
instance Bioshake.Tags.IsBcf a0 => Bioshake.Tags.IsBcf (Bioshake.All a0)
instance Bioshake.Tags.IsBed a0 => Bioshake.Tags.IsBed (Bioshake.All a0)
instance Bioshake.Tags.IsCSV a0 => Bioshake.Tags.IsCSV (Bioshake.All a0)
instance Bioshake.Tags.IsGff a0 => Bioshake.Tags.IsGff (Bioshake.All a0)
instance Bioshake.Tags.IsMPileup a0 => Bioshake.Tags.IsMPileup (Bioshake.All a0)
instance Bioshake.Tags.IsSam a0 => Bioshake.Tags.IsSam (Bioshake.All a0)
instance Bioshake.Tags.IsSeqzGZ a0 => Bioshake.Tags.IsSeqzGZ (Bioshake.All a0)
instance Bioshake.Tags.IsTSV a0 => Bioshake.Tags.IsTSV (Bioshake.All a0)
instance Bioshake.Tags.IsVCF a0 => Bioshake.Tags.IsVCF (Bioshake.All a0)
instance Bioshake.Tags.IsTGZ a0 => Bioshake.Tags.IsTGZ (Bioshake.All a0)
instance Bioshake.Tags.IsCov a0 => Bioshake.Tags.IsCov (Bioshake.All a0)
instance Bioshake.Tags.PairedEnd a0 => Bioshake.Tags.PairedEnd (Bioshake.All a0)
instance Bioshake.Tags.Sorted a0 => Bioshake.Tags.Sorted (Bioshake.All a0)
instance Bioshake.Tags.IsFastQ a0 => Bioshake.Tags.IsFastQ (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.DeDuped a0 => Bioshake.Tags.DeDuped (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.HasRG a0 => Bioshake.Tags.HasRG (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsBam a0 => Bioshake.Tags.IsBam (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsBcf a0 => Bioshake.Tags.IsBcf (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsBed a0 => Bioshake.Tags.IsBed (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsCSV a0 => Bioshake.Tags.IsCSV (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsGff a0 => Bioshake.Tags.IsGff (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsMPileup a0 => Bioshake.Tags.IsMPileup (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsSam a0 => Bioshake.Tags.IsSam (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsSeqzGZ a0 => Bioshake.Tags.IsSeqzGZ (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsTSV a0 => Bioshake.Tags.IsTSV (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsVCF a0 => Bioshake.Tags.IsVCF (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsTGZ a0 => Bioshake.Tags.IsTGZ (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.IsCov a0 => Bioshake.Tags.IsCov (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.PairedEnd a0 => Bioshake.Tags.PairedEnd (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Tags.Sorted a0 => Bioshake.Tags.Sorted (a0 Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Types.Compilable a => Bioshake.Types.Compilable (Bioshake.All a)
instance Bioshake.Types.Pathable a => Bioshake.Types.Pathable (Bioshake.All a)
instance Bioshake.Referenced a => Bioshake.Referenced (Bioshake.All a)
instance Bioshake.Capture a => Bioshake.Capture (Bioshake.All a)
instance GHC.Show.Show a => GHC.Show.Show (Bioshake.All a)
instance GHC.Show.Show Bioshake.Out
instance Bioshake.Referenced a => Bioshake.Referenced (a Bioshake.Types.:-> b)
instance Bioshake.Capture a => Bioshake.Capture (a Bioshake.Types.:-> b)
instance Bioshake.Types.Pathable (a Bioshake.Types.:-> Bioshake.Out)
instance Bioshake.Types.Pathable a => Bioshake.Types.Buildable (a Bioshake.Types.:-> Bioshake.Out)


-- | Bioshake is built on a lot of instantiation and template haskell can
--   be used to derive instances for the most common types of processes. In
--   particular, this module provides TH functions for handling either
--   single or multithreaded processes with single or multiple outputs (of
--   the same type). Most things fit into these categories.
module Bioshake.TH
sha1 :: ByteString -> Digest SHA1
hashPath :: Binary b => b -> FilePath

-- | Generate instances of <a>Pathable</a> and for all the tags associated
--   with the output (both transitive <a>Bioshake.Tags</a> and absolute
--   <a>Bioshake.Tags</a>) for actions that produce a single output file.
--   Transitive <a>Bioshake.Tags</a> are those that if they exist on the
--   input then they will exist on the output (e.g., a <a>Sorted</a> input
--   may result in a <a>Sorted</a> output because the action does not
--   reorder things). Absolute <a>Bioshake.Tags</a> are those that hold on
--   all outputs of the action. These include the file type (e.g.,
--   <a>IsBam</a>).
makeSingleTypes :: Name -> [Name] -> [Name] -> DecsQ

-- | Same as <a>makeSingleTypes</a> but for actions that produce an output
--   file for each input file.
makeMultiTypes :: Name -> [Name] -> [Name] -> DecsQ
makeSingleThread :: Name -> [Name] -> Name -> Q [Dec]
makeSingleCluster :: Name -> [Name] -> Name -> Q [Dec]
makeThreaded :: Name -> [Name] -> Name -> Q [Dec]
makeCluster :: Name -> [Name] -> Name -> Q [Dec]
class Args a
args :: Args a => a -> [String]
class CArgs a
cmdArgs :: CArgs a => [String] -> a
type (|->) a b = a
data CmdF a
[CmdF] :: [String] -> a -> CmdF a
[MemLimit] :: Int -> Cmd () -> a -> CmdF a
[FinallyF] :: Cmd () -> IO () -> a -> CmdF a
type Cmd = FreeT CmdF Action
cmdFinally :: Cmd () -> IO () -> Cmd ()
memLimit :: Int -> Cmd () -> Cmd ()
withTempDirectory' :: FilePath -> String -> (FilePath -> Cmd ()) -> Cmd ()
run :: CArgs a => a |-> Cmd ()
withCmd :: Implicit Resource => Int -> Cmd () -> Action ()
withSubmit :: Cmd () -> [Either Config TOption] -> Action ()
instance GHC.Base.Functor Bioshake.TH.CmdF
instance Bioshake.TH.Args GHC.Base.String
instance Bioshake.TH.Args [GHC.Base.String]
instance Bioshake.TH.CArgs [GHC.Base.String]
instance (Bioshake.TH.Args a, Bioshake.TH.CArgs r) => Bioshake.TH.CArgs (a -> r)
instance Bioshake.TH.CArgs (Bioshake.TH.Cmd ())

module Bioshake.ADTEx
call :: Call ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Capture a0, Bioshake.Tags.IsBam a0, Bioshake.Tags.DeDuped a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.ADTEx.Call ())

module Bioshake.Cluster.ADTEx
call :: Implicit Config => Call Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Capture a0, Bioshake.Tags.IsBam a0, Bioshake.Tags.DeDuped a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.ADTEx.Call Bioshake.Cluster.Torque.Config)

module Bioshake.BWA
align :: Implicit Threads => Align Threads
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsFastQ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.BWA.Align Bioshake.Types.Threads)

module Bioshake.Cluster.BWA
align :: Implicit Config => Align Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsFastQ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.BWA.Align Bioshake.Cluster.Torque.Config)

module Bioshake.Bedtools
captureOnly :: CaptureOnly ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Capture a0, Bioshake.Tags.IsVCF a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Bedtools.CaptureOnly ())

module Bioshake.Cluster.Bedtools
captureOnly :: Implicit Config => CaptureOnly Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Capture a0, Bioshake.Tags.IsVCF a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Bedtools.CaptureOnly Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.Cutadapt
trim :: Implicit Config => Seq -> Trim Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsFastQ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Cutadapt.Trim Bioshake.Cluster.Torque.Config)

module Bioshake.Cutadapt
trim :: Seq -> Trim ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsFastQ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Cutadapt.Trim ())

module Bioshake.Cluster.FREEC
cNVExome :: Implicit Config => CNVExome Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Capture a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.FREEC.CNVExome Bioshake.Cluster.Torque.Config)

module Bioshake.FREEC
cNVExome :: Implicit Threads => CNVExome Threads
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Capture a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.FREEC.CNVExome Bioshake.Types.Threads)

module Bioshake.Cluster.Picard
markDups :: Implicit Config => MarkDups Config
deDup :: Implicit Config => DeDup Config
fixMates :: Implicit Config => FixMates Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.FixMates Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.DeDup Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.MarkDups Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.Platypus
call :: Implicit Config => Call Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Platypus.Call Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.Samtools
indexRules :: Rules ()
addRGLine :: Implicit Config => String -> AddRGLine Config
sortBam :: Implicit Config => SortBam Config
mappedOnly :: Implicit Config => MappedOnly Config
pileup :: Implicit Config => Pileup Config
deDup :: Implicit Config => DeDup Config
bedCov :: Implicit Config => BedCov Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0, Bioshake.Capture a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.BedCov Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.DeDup Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0, Bioshake.Referenced a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.Pileup Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsSam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.MappedOnly Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.SortBam Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.AddRGLine Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.Sequenza
pileup2Seqz :: Implicit Config => Pileup2Seqz Config
bin :: Implicit Config => Int -> Bin Config

-- | Tags a type with GC content; this is not part of <a>Referenced</a> as
--   it is a sequenza specific format.
class GC a
getGC :: GC a => a -> FilePath
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsSeqzGZ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Sequenza.Bin Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0, Bioshake.Internal.Sequenza.GC a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Sequenza.Pileup2Seqz Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.SnpEff
annotate :: Implicit Config => Annotate Config
dBNSFP :: Implicit Config => DBNSFP Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsVCF a0, Bioshake.Internal.SnpEff.SnpEffAnnotated a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.SnpEff.DBNSFP Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsVCF a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.SnpEff.Annotate Bioshake.Cluster.Torque.Config)

module Bioshake.Cluster.Varscan
callSomatic :: Implicit Config => CallSomatic Config
copyNumber :: Implicit Config => CopyNumber Config
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Varscan.CopyNumber Bioshake.Cluster.Torque.Config)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Varscan.CallSomatic Bioshake.Cluster.Torque.Config)

module Bioshake.Picard
markDups :: MarkDups ()
deDup :: DeDup ()
fixMates :: FixMates ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.FixMates ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.DeDup ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.Sorted a0, Bioshake.Tags.PairedEnd a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Picard.MarkDups ())

module Bioshake.Platypus
call :: Implicit Threads => Call Threads
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Platypus.Call Bioshake.Types.Threads)

module Bioshake.Samtools
addRGLine :: String -> AddRGLine ()
sortBam :: Implicit Threads => SortBam Threads
mappedOnly :: Implicit Threads => MappedOnly Threads
pileup :: Pileup ()
deDup :: DeDup ()
bedCov :: BedCov ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0, Bioshake.Capture a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.BedCov ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.DeDup ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0, Bioshake.Referenced a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.Pileup ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsSam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.MappedOnly Bioshake.Types.Threads)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.SortBam Bioshake.Types.Threads)
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsBam a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Samtools.AddRGLine ())

module Bioshake.Sequenza
pileup2Seqz :: Pileup2Seqz ()
bin :: Int -> Bin ()

-- | Tags a type with GC content; this is not part of <a>Referenced</a> as
--   it is a sequenza specific format.
class GC a
getGC :: GC a => a -> FilePath
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsSeqzGZ a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Sequenza.Bin ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0, Bioshake.Internal.Sequenza.GC a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Sequenza.Pileup2Seqz ())

module Bioshake.SnpEff
annotate :: Annotate ()
dBNSFP :: DBNSFP ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsVCF a0, Bioshake.Internal.SnpEff.SnpEffAnnotated a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.SnpEff.DBNSFP ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Referenced a0, Bioshake.Tags.IsVCF a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.SnpEff.Annotate ())

module Bioshake.Varscan
callSomatic :: CallSomatic ()
copyNumber :: CopyNumber ()
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Varscan.CopyNumber ())
instance (Bioshake.Types.Pathable a0, GHC.Show.Show a0, Bioshake.Tags.IsMPileup a0) => Bioshake.Types.Buildable (a0 Bioshake.Types.:-> Bioshake.Internal.Varscan.CallSomatic ())
